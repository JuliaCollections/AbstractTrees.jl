<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · AbstractTrees.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">AbstractTrees.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#The-Abstract-Tree-Interface"><span>The Abstract Tree Interface</span></a></li><li><a class="tocitem" href="#The-Indexed-Tree-Interface"><span>The Indexed Tree Interface</span></a></li><li><a class="tocitem" href="#The-AbstractNode-Type"><span>The <code>AbstractNode</code> Type</span></a></li><li><a class="tocitem" href="#Type-Stability-and-Performance"><span>Type Stability and Performance</span></a></li><li><a class="tocitem" href="#Additional-Functions"><span>Additional Functions</span></a></li><li><a class="tocitem" href="#Example-Implementations"><span>Example Implementations</span></a></li></ul></li><li><a class="tocitem" href="iteration/">Iteration</a></li><li><a class="tocitem" href="internals/">Internals</a></li><li><a class="tocitem" href="faq/">FAQ</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaCollections/AbstractTrees.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="AbstractTrees.jl"><a class="docs-heading-anchor" href="#AbstractTrees.jl">AbstractTrees.jl</a><a id="AbstractTrees.jl-1"></a><a class="docs-heading-anchor-permalink" href="#AbstractTrees.jl" title="Permalink"></a></h1><p>This package provides an interface for handling <a href="https://en.wikipedia.org/wiki/Tree_(graph_theory)">tree</a>-like data structures in Julia.</p><p>Specifically, a tree consists of a set of nodes (each of which can be represented by any data type) which are connected in a graph with no cycles.  For example, each object in the nested array <code>[1, [2, 3]]</code> can be represented by a tree in which the object <code>[1, [2, 3]]</code> is itself the root of the tree, <code>1</code> and <code>[2,3]</code> are its children and <code>1</code>, <code>2</code> and <code>3</code> are the leaves.</p><p>Using this package involves implementing the abstract tree interface which, at a minimum, requires defining the function <a href="#AbstractTrees.children"><code>AbstractTrees.children</code></a> for an object.</p><p>See below for a complete guide on how to implement the interface.</p><h2 id="The-Abstract-Tree-Interface"><a class="docs-heading-anchor" href="#The-Abstract-Tree-Interface">The Abstract Tree Interface</a><a id="The-Abstract-Tree-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#The-Abstract-Tree-Interface" title="Permalink"></a></h2><h3 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h3><p>All trees <em>must</em> define <a href="#AbstractTrees.children"><code>children</code></a>.</p><p>By default <code>children</code> returns an empty tuple and <code>parent</code> returns <code>nothing</code>, meaning that all objects which do not define the abstract trees interface can be considered the sole node of a tree.</p><article class="docstring"><header><a class="docstring-binding" id="AbstractTrees.children" href="#AbstractTrees.children"><code>AbstractTrees.children</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">children(node)</code></pre><p>Get the immediate children of node <code>node</code>.</p><p>By default, every object is a parent node of an empty set of children.  This is to make it simpler to define trees with nodes of different types, for example arrays are trees regardless of their <code>eltype</code>.</p><p><strong>REQUIRED</strong>: This is required for all tree nodes with non-empty sets of children.  If it is not possible to infer the children from the node alone, this should be defined for a wrapper object which does.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/AbstractTrees.jl/blob/c63e1dbf65090dfb5060ee6c7139845256310ef7/src/base.jl#L34-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractTrees.nodevalue-Tuple{Any}" href="#AbstractTrees.nodevalue-Tuple{Any}"><code>AbstractTrees.nodevalue</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nodevalue(node)</code></pre><p>Get the value associated with a node in a tree.  This removes wrappers such as <a href="@ref"><code>Indexed</code></a> or <a href="internals/#AbstractTrees.TreeCursor"><code>TreeCursor</code></a>s.</p><p>By default, this function is the identity.</p><p><strong>OPTIONAL</strong>: This should be implemented with any tree for which nodes have some &quot;value&quot; apart from the node itself. For example, integers cannot themselves be tree nodes, to create a tree in which the &quot;nodes&quot; are integers one can do something like</p><pre><code class="language-julia">struct IntNode
    value::Int
    children::Vector{IntNode}
end

AbstractTrees.nodevalue(n::IntNode) = n.value</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/AbstractTrees.jl/blob/c63e1dbf65090dfb5060ee6c7139845256310ef7/src/base.jl#L2-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractTrees.parent" href="#AbstractTrees.parent"><code>AbstractTrees.parent</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">parent(node)</code></pre><p>Get the immediate parent of a node <code>node</code>.</p><p>By default all objects are considered nodes of a trivial tree with no children and no parents.  That is, the default method is simply <code>parent(node) = nothing</code>.</p><p><strong>OPTIONAL</strong>: The 1-argument version of this function must be implemented for nodes with the <a href="#AbstractTrees.StoredParents"><code>StoredParents</code></a> trait.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/AbstractTrees.jl/blob/c63e1dbf65090dfb5060ee6c7139845256310ef7/src/base.jl#L82-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractTrees.nextsibling" href="#AbstractTrees.nextsibling"><code>AbstractTrees.nextsibling</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nextsibling(node)</code></pre><p>Get the next sibling (child of the same parent) of the tree node <code>node</code>.  The returned node should be the same as the node that would be returned after <code>node</code> when iterating over <code>(children ∘ parent)(node)</code>.</p><p><strong>OPTIONAL</strong>: This function is required for nodes with the <a href="#AbstractTrees.StoredSiblings"><code>StoredSiblings</code></a> trait.  There is no default definition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/AbstractTrees.jl/blob/c63e1dbf65090dfb5060ee6c7139845256310ef7/src/base.jl#L47-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractTrees.prevsibling" href="#AbstractTrees.prevsibling"><code>AbstractTrees.prevsibling</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">prevsibling(node)</code></pre><p>Get the previous sibling (child of the same parent) of the tree node <code>node</code>.  The returned node should be the same as the node that would be returned prior to <code>node</code> when iterating over <code>(children ∘ parent)(node)</code>.</p><p><strong>OPTIONAL</strong>: This function is optional in all cases.  Default AbstractTrees method assume that it is impossible to obtain the previous sibling and all iterators act in the &quot;forward&quot; direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/AbstractTrees.jl/blob/c63e1dbf65090dfb5060ee6c7139845256310ef7/src/base.jl#L58-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractTrees.childrentype" href="#AbstractTrees.childrentype"><code>AbstractTrees.childrentype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">childrentype(::Type{T})
childrentype(n)</code></pre><p>Indicates the type of the children (the <em>collection</em> of children, not individual children) of the tree node <code>n</code> or its type <code>T</code>.  <a href="#AbstractTrees.children"><code>children</code></a> should return an object of this type.</p><p>If the <code>childrentype</code> can be inferred from the type of the node alone, the type <code>::Type{T}</code> definition is preferred (the latter will fall back to it).</p><p><strong>OPTIONAL</strong>: In most cases, <a href="#AbstractTrees.childtype"><code>childtype</code></a> is used instead.  If <code>childtype</code> is not defined it will fall back to <code>eltype ∘ childrentype</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/AbstractTrees.jl/blob/c63e1dbf65090dfb5060ee6c7139845256310ef7/src/traits.jl#L133-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractTrees.childtype" href="#AbstractTrees.childtype"><code>AbstractTrees.childtype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">childtype(::Type{T})
childtype(n)</code></pre><p>Indicates the type of children of the tree node <code>n</code> or its type <code>T</code>.</p><p>If <code>childtype</code> can be inferred from the type of the node alone, the type <code>::Type{T}</code> definition is preferred (the latter will fall back to it).</p><p><strong>OPTIONAL</strong>: It is strongly recommended to define this wherever possible, as without it almost no tree algorithms can be type-stable.  If <code>childrentype</code> is defined and can be known from the node type alone, this function will fall back to <code>eltype(childrentype(T))</code>.  If this gives a correct result it&#39;s not necessary to define <code>childtype</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/AbstractTrees.jl/blob/c63e1dbf65090dfb5060ee6c7139845256310ef7/src/traits.jl#L149-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractTrees.childstatetype" href="#AbstractTrees.childstatetype"><code>AbstractTrees.childstatetype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">childstatetype(::Type{T})
childstatetype(n)</code></pre><p>Indicates the type of the iteration state of the tree node <code>n</code> or its type <code>T</code>.  This is used by tree traversal algorithms which must retain this state.  It therefore is necessary to define this to ensure that most tree traversal is type stable.</p><p><strong>OPTIONAL</strong>: Type inference is used to attempt to</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/AbstractTrees.jl/blob/c63e1dbf65090dfb5060ee6c7139845256310ef7/src/traits.jl#L165-L174">source</a></section></article><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>In general nodes of a tree do not all need to have the same type, but it is much easier to achieve type-stability if they do.  To specify that all nodes of a tree must have the same type, one should define <code>Base.eltype(::Type{&lt;:TreeIterator{T}})</code>, see <a href="iteration/#Iteration">Iteration</a>.</p></div></div><h3 id="Traits"><a class="docs-heading-anchor" href="#Traits">Traits</a><a id="Traits-1"></a><a class="docs-heading-anchor-permalink" href="#Traits" title="Permalink"></a></h3><h4 id="ParentLinks"><a class="docs-heading-anchor" href="#ParentLinks"><code>ParentLinks</code></a><a id="ParentLinks-1"></a><a class="docs-heading-anchor-permalink" href="#ParentLinks" title="Permalink"></a></h4><p>The default value of <code>ParentLinks</code> is <code>ImplicitParents</code>.</p><p>Types with the <code>StoredParents</code> trait <em>must</em> define <a href="#AbstractTrees.parent"><code>parent</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="AbstractTrees.ParentLinks" href="#AbstractTrees.ParentLinks"><code>AbstractTrees.ParentLinks</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ParentLinks(::Type{T})
ParentLinks(tree)</code></pre><p>A trait which indicates whether a tree node stores references to its parents (<code>StoredParents()</code>) or if the parents must be inferred from the tree structure (<code>ImplicitParents()</code>).</p><p>Trees for which <code>ParentLinks</code> returns <code>StoredParents()</code> <em>MUST</em> implement <a href="#AbstractTrees.parent"><code>parent</code></a>.</p><p>If <code>StoredParents()</code>, all nodes in the tree must also have <code>StoredParents()</code>, otherwise use <code>ImplicitParents()</code>.</p><p><strong>OPTIONAL</strong>: This should be implemented for a tree if parents of nodes are stored</p><pre><code class="language-julia">AbstractTrees.ParentLinks(::Type{&lt;:TreeType}) = AbstractTrees.StoredParents()
parent(t::TreeType) = get_parent(t)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/AbstractTrees.jl/blob/c63e1dbf65090dfb5060ee6c7139845256310ef7/src/traits.jl#L2-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractTrees.ImplicitParents" href="#AbstractTrees.ImplicitParents"><code>AbstractTrees.ImplicitParents</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ImplicitParents &lt;: ParentLinks</code></pre><p>Indicates that the tree does not store parents.  In these cases parents must be inferred from the tree structure and cannot be inferred through a single node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/AbstractTrees.jl/blob/c63e1dbf65090dfb5060ee6c7139845256310ef7/src/traits.jl#L37-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractTrees.StoredParents" href="#AbstractTrees.StoredParents"><code>AbstractTrees.StoredParents</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">StoredParents &lt;: ParentLinks</code></pre><p>Indicates that this node stores parent links explicitly. The implementation is responsible for defining the parentind function to expose this information.</p><p>If a node in a tree has this trait, so must all connected nodes.  If this is not the case, use <a href="#AbstractTrees.ImplicitParents"><code>ImplicitParents</code></a> instead.</p><p><strong>Required Methods</strong></p><ul><li><a href="#AbstractTrees.parent"><code>parent</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/AbstractTrees.jl/blob/c63e1dbf65090dfb5060ee6c7139845256310ef7/src/traits.jl#L22-L34">source</a></section></article><h4 id="SiblingLinks"><a class="docs-heading-anchor" href="#SiblingLinks"><code>SiblingLinks</code></a><a id="SiblingLinks-1"></a><a class="docs-heading-anchor-permalink" href="#SiblingLinks" title="Permalink"></a></h4><p>The default value of <code>SiblingLinks</code> is <code>ImplicitSiblings</code>.</p><p>Types with the <code>StoredSiblings</code> trait <em>must</em> define <a href="#AbstractTrees.nextsibling"><code>nextsibling</code></a> and <em>may</em> define <a href="#AbstractTrees.prevsibling"><code>prevsibling</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="AbstractTrees.SiblingLinks" href="#AbstractTrees.SiblingLinks"><code>AbstractTrees.SiblingLinks</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SiblingLinks(::Type{T})
SiblingLinks(tree)</code></pre><p>A trait which indicates whether a tree node stores references to its siblings (<code>StoredSiblings()</code>) or must be inferred from the tree structure (<code>ImplicitSiblings()</code>).</p><p>If a node has the trait <code>StoredSiblings()</code>, so must all connected nodes in the tree.  Otherwise, use <code>ImplicitSiblings()</code> instead.</p><p><strong>OPTIONAL</strong>: This should be implemented for a tree if siblings of nodes are stored</p><pre><code class="language-julia">AbstractTrees.SiblingLinks(::Type{&lt;:TreeType}) = AbstractTrees.StoredSiblings()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/AbstractTrees.jl/blob/c63e1dbf65090dfb5060ee6c7139845256310ef7/src/traits.jl#L48-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractTrees.ImplicitSiblings" href="#AbstractTrees.ImplicitSiblings"><code>AbstractTrees.ImplicitSiblings</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ImplicitSiblings &lt;: SiblingLinks</code></pre><p>Indicates that tree nodes do not store references to siblings so that they must be inferred from the tree structure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/AbstractTrees.jl/blob/c63e1dbf65090dfb5060ee6c7139845256310ef7/src/traits.jl#L79-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractTrees.StoredSiblings" href="#AbstractTrees.StoredSiblings"><code>AbstractTrees.StoredSiblings</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">StoredSiblings &lt;: SiblingLinks</code></pre><p>Indicates that this tree node stores sibling links explicitly, or can compute them quickly (e.g. because the tree has a (small) fixed branching ratio, so the current index of a node can be determined by quick linear search).</p><p>If a node has this trait, so must all connected nodes in the tree.  Otherwise, use <code>ImplicitSiblings()</code> instead.</p><p><strong>Required Methods</strong></p><ul><li><a href="#AbstractTrees.nextsibling"><code>nextsibling</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/AbstractTrees.jl/blob/c63e1dbf65090dfb5060ee6c7139845256310ef7/src/traits.jl#L65-L76">source</a></section></article><h4 id="ChildIndexing"><a class="docs-heading-anchor" href="#ChildIndexing"><code>ChildIndexing</code></a><a id="ChildIndexing-1"></a><a class="docs-heading-anchor-permalink" href="#ChildIndexing" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="AbstractTrees.ChildIndexing" href="#AbstractTrees.ChildIndexing"><code>AbstractTrees.ChildIndexing</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ChildIndexing(::Type{N})
ChildIndexing(node)</code></pre><p>A trait indicating whether the tree node <code>n</code> has children (as returned by <a href="#AbstractTrees.children"><code>children</code></a>) which can be indexed using 1-based indexing. Options are either <a href="#AbstractTrees.NonIndexedChildren"><code>NonIndexedChildren</code></a> (default) or <a href="#AbstractTrees.IndexedChildren"><code>IndexedChildren</code></a>.</p><p>To declare that the tree <code>TreeType</code> supports one-based indexing on the children, define</p><pre><code class="language-julia">AbstractTrees.ChildIndexing(::Type{&lt;:TreeType}) = AbstractTrees.IndexedChildren()</code></pre><p>If a node has the <code>IndexedChildren()</code> so must all connected nodes in the tree.  Otherwise, use <code>NonIndexedChildren()</code> instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/AbstractTrees.jl/blob/c63e1dbf65090dfb5060ee6c7139845256310ef7/src/traits.jl#L90-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractTrees.NonIndexedChildren" href="#AbstractTrees.NonIndexedChildren"><code>AbstractTrees.NonIndexedChildren</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NonIndexedChildren &lt;: ChildIndexing</code></pre><p>Indicates that the object returned by <code>children(n)</code> where <code>n</code> is a tree node is not necessarily indexable. This trait applies to any tree which cannot guarantee indexable children in all cases, regardless of whether the tree is indexable in special cases.  For example, <code>Array</code> has this trait even though there is a large class of indexable trees consisting of arrays.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/AbstractTrees.jl/blob/c63e1dbf65090dfb5060ee6c7139845256310ef7/src/traits.jl#L119-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractTrees.IndexedChildren" href="#AbstractTrees.IndexedChildren"><code>AbstractTrees.IndexedChildren</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">IndexedChildren &lt;: ChildIndexing</code></pre><p>Indicates that the object returned by <code>children(n)</code> where <code>n</code> is a tree node is indexable (1-based).</p><p>If a node has this trait so must all connected nodes in the tree.  Otherwise, use <code>NonIndexedChildren()</code> instead.</p><p><strong>Required Methods</strong></p><ul><li>A node <code>node</code> with this trait must return an indexable object from <code>children(node)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/AbstractTrees.jl/blob/c63e1dbf65090dfb5060ee6c7139845256310ef7/src/traits.jl#L107-L116">source</a></section></article><p>The default value of <code>ChildIndexing</code> is <code>NonIndexedChildren</code>.</p><p>Types with the <code>IndexedChildren</code> trait <em>must</em> return an indexable object from <code>children</code> (i.e. <code>children(node)[idx]</code> must be valid for positive integers <code>idx</code>).</p><h4 id="NodeType"><a class="docs-heading-anchor" href="#NodeType"><code>NodeType</code></a><a id="NodeType-1"></a><a class="docs-heading-anchor-permalink" href="#NodeType" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="AbstractTrees.NodeType" href="#AbstractTrees.NodeType"><code>AbstractTrees.NodeType</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NodeType(::Type)
NodeType(node)</code></pre><p>A trait which specifiees whether a tree has a predictable node type (<code>HasNodeType()</code>) or not (<code>NodeTypeUnknown()</code>).</p><p>This is analogous to <code>Base.IteratorEltype</code>.  In particular the <code>IteratorEltype</code> of <a href="iteration/#AbstractTrees.TreeIterator"><code>TreeIterator</code></a> is dictated by this trait.</p><p>The default value is <code>NodeTypeUnknown()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/AbstractTrees.jl/blob/c63e1dbf65090dfb5060ee6c7139845256310ef7/src/traits.jl#L179-L189">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractTrees.NodeTypeUnknown" href="#AbstractTrees.NodeTypeUnknown"><code>AbstractTrees.NodeTypeUnknown</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NodeTypeUnknown &lt;: NodeType</code></pre><p>Indicates that this node is connected to a tree for which it cannot be guaranteed that all nodes have the same type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/AbstractTrees.jl/blob/c63e1dbf65090dfb5060ee6c7139845256310ef7/src/traits.jl#L199-L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractTrees.HasNodeType" href="#AbstractTrees.HasNodeType"><code>AbstractTrees.HasNodeType</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">HasNodeType &lt;: NodeType</code></pre><p>Indicates that this node is connected to a tree for which <em>all</em> nodes have types descended from <code>eltype(node)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/AbstractTrees.jl/blob/c63e1dbf65090dfb5060ee6c7139845256310ef7/src/traits.jl#L192-L196">source</a></section></article><p>Providing the <code>HasNodeType</code> trait will guarantee that all nodes connected to the node must be of the type returned by <a href="@ref"><code>nodetype</code></a>.</p><p>An important use case of this trait is to guarantee the return types of a <code>TreeIterator</code>.  Tree nodes with <code>NodeTypeUnknown</code> cannot have type-stable iteration over the entire tree.</p><p>For example</p><pre><code class="language-julia">struct ExampleNode
    x::Int
    children::Vector{ExampleNode}
end

AbstractTrees.nodevalue(x::ExampleNode) = x.x
AbstractTrees.children(x::ExampleNode) = x.children

AbstractTrees.NodeType(::Type{&lt;:ExampleNode}) = HasNodeType()
AbstractTrees.nodetype(::Type{&lt;:ExampleNode}) = ExampleNode</code></pre><p>In this example, iteration over a tree of <code>ExampleNode</code>s is type-stable with <code>eltype</code> <code>ExampleNode</code>.</p><p>Providing the <code>nodetype(::Type)</code> method is preferable to defining <code>nodetype(::ExampleNode)</code> because it ensures that <code>nodetype</code> can be involved at compile time even if values are not known.</p><h2 id="The-Indexed-Tree-Interface"><a class="docs-heading-anchor" href="#The-Indexed-Tree-Interface">The Indexed Tree Interface</a><a id="The-Indexed-Tree-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#The-Indexed-Tree-Interface" title="Permalink"></a></h2><p>The abstract tree interface assumes that all information about the descendants of a node is accessible through the node itself.  The objects which can implement that interface are the nodes of a tree, not the tree itself.</p><p>The interface for trees which do not possess nodes for which tree structure can be inferred from the nodes alone is different.  This is done by wrapping nodes in the <a href="#AbstractTrees.IndexNode"><code>IndexNode</code></a> nodes which allow nodes to be accessed from a centralized tree object.</p><article class="docstring"><header><a class="docstring-binding" id="AbstractTrees.IndexNode" href="#AbstractTrees.IndexNode"><code>AbstractTrees.IndexNode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">IndexNode{T,I}</code></pre><p>The node of a tree which implements the indexed tree interface.  Such a tree consists of an object <code>tree</code> from which nodes can be obtained with the two-argument method of <a href="#AbstractTrees.nodevalue-Tuple{Any}"><code>nodevalue</code></a> which by default calls <code>getindex</code>.</p><p>An <code>IndexNode</code> implements the tree interface, and can be thought of an adapter from an object that implements the indexed tree interface to one that implements the tree interface.</p><p><code>IndexNode</code> do not store the value associated with the node but can obtain it by calling <a href="#AbstractTrees.nodevalue-Tuple{Any}"><code>nodevalue</code></a>.</p><p><strong>Constructors</strong></p><pre><code class="language-julia">IndexNode(tree, node_index)

IndexNode(tree) = IndexNode(tree, rootindex(tree))  # one-argument constructor requires `rootindex`</code></pre><p>Here <code>tree</code> is an object which stores or can obtain information for the entire tree structure, and <code>node_index</code> is the index of the node for which <code>node_index</code> is being constructed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/AbstractTrees.jl/blob/c63e1dbf65090dfb5060ee6c7139845256310ef7/src/indexing.jl#L91-L111">source</a></section></article><h3 id="Functions-2"><a class="docs-heading-anchor" href="#Functions-2">Functions</a><a class="docs-heading-anchor-permalink" href="#Functions-2" title="Permalink"></a></h3><p>All indexed trees <em>must</em> implement <a href="#AbstractTrees.childindices"><code>childindices</code></a>.</p><p>Indexed trees rely on <a href="#AbstractTrees.nodevalue-Tuple{Any, Any}"><code>nodevalue(::Any, ::Any)</code></a> for obtaining the value of a node given the tree and index.  By default, <code>nodevalue(tree, idx) = tree[idx]</code>, trees which do not store nodes in this way should define <code>nodevalue</code>.</p><p>Indexed trees can define <a href="#AbstractTrees.ParentLinks"><code>ParentLinks</code></a> or <a href="#AbstractTrees.SiblingLinks"><code>SiblingLinks</code></a>.  The <a href="#AbstractTrees.IndexNode"><code>IndexNode</code></a>s of a tree will inherit these traits from the wrapped tree.</p><article class="docstring"><header><a class="docstring-binding" id="AbstractTrees.childindices" href="#AbstractTrees.childindices"><code>AbstractTrees.childindices</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">childindices(tree, node_index)</code></pre><p>Get the indices of the children of the node of tree <code>tree</code> specified by <code>node_index</code>.</p><p>To be consistent with <a href="#AbstractTrees.children"><code>children</code></a>, by default this returns an empty tuple.</p><p><strong>REQUIRED</strong> for indexed trees:  Indexed trees, i.e. trees that do not implement <a href="#AbstractTrees.children"><code>children</code></a> must implement this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/AbstractTrees.jl/blob/c63e1dbf65090dfb5060ee6c7139845256310ef7/src/indexing.jl#L35-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractTrees.nodevalue-Tuple{Any, Any}" href="#AbstractTrees.nodevalue-Tuple{Any, Any}"><code>AbstractTrees.nodevalue</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nodevalue(tree, node_index)</code></pre><p>Get the value of the node specified by <code>node_index</code> from the indexed tree object <code>tree</code>.</p><p>By default, this falls back to <code>tree[node_index]</code>.</p><p><strong>OPTIONAL</strong>: Indexed trees only require this if the fallback to <code>getindex</code> is not sufficient.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/AbstractTrees.jl/blob/c63e1dbf65090dfb5060ee6c7139845256310ef7/src/base.jl#L23-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractTrees.parentindex" href="#AbstractTrees.parentindex"><code>AbstractTrees.parentindex</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">parentindex(tree, node_index)</code></pre><p>Get the index of the parent of the node of tree <code>tree</code> specified by <code>node_index</code>.</p><p>Nodes that have no parent (i.e. the root node) should return <code>nothing</code>.</p><p><strong>OPTIONAL</strong>: Indexed trees with the <a href="#AbstractTrees.StoredParents"><code>StoredParents</code></a> trait must implement this.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/AbstractTrees.jl/blob/c63e1dbf65090dfb5060ee6c7139845256310ef7/src/indexing.jl#L47-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractTrees.nextsiblingindex" href="#AbstractTrees.nextsiblingindex"><code>AbstractTrees.nextsiblingindex</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nextsiblingindex(tree, node_index)</code></pre><p>Get the index of the next sibling of the node of tree <code>tree</code> specified by <code>node_index</code>.</p><p>Nodes which have no next sibling should return <code>nothing</code>.</p><p><strong>OPTIONAL</strong>: Indexed trees with the <a href="#AbstractTrees.StoredSiblings"><code>StoredSiblings</code></a> trait must implement this.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/AbstractTrees.jl/blob/c63e1dbf65090dfb5060ee6c7139845256310ef7/src/indexing.jl#L58-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractTrees.prevsiblingindex" href="#AbstractTrees.prevsiblingindex"><code>AbstractTrees.prevsiblingindex</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">prevsiblingindex(tree, node_index)</code></pre><p>Get the index of the previous sibling of the node of tree <code>tree</code> specified by <code>node_index</code>.</p><p>Nodes which have no previous sibling should return <code>nothing</code>.</p><p><strong>OPTIONAL</strong>: Indexed trees that have <a href="#AbstractTrees.StoredSiblings"><code>StoredSiblings</code></a> can implement this, but no built-in tree algorithms require it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/AbstractTrees.jl/blob/c63e1dbf65090dfb5060ee6c7139845256310ef7/src/indexing.jl#L69-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractTrees.rootindex" href="#AbstractTrees.rootindex"><code>AbstractTrees.rootindex</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rootindex(tree)</code></pre><p>Get the root index of the indexed tree <code>tree</code>.</p><p><strong>OPTIONAL</strong>: The single-argument constructor for <a href="#AbstractTrees.IndexNode"><code>IndexNode</code></a> requires this, but it is not required for any built-in tree algorithms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/AbstractTrees.jl/blob/c63e1dbf65090dfb5060ee6c7139845256310ef7/src/indexing.jl#L81-L88">source</a></section></article><h2 id="The-AbstractNode-Type"><a class="docs-heading-anchor" href="#The-AbstractNode-Type">The <code>AbstractNode</code> Type</a><a id="The-AbstractNode-Type-1"></a><a class="docs-heading-anchor-permalink" href="#The-AbstractNode-Type" title="Permalink"></a></h2><p>It is not required that objects implementing the AbstractTrees.jl interface are of this type, but it can be used to indicate that an object <em>must</em> implement the interface.</p><article class="docstring"><header><a class="docstring-binding" id="AbstractTrees.AbstractNode" href="#AbstractTrees.AbstractNode"><code>AbstractTrees.AbstractNode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractNode{T}</code></pre><p>Abstract type of tree nodes that implement the AbstractTrees.jl interface.</p><p>It is <em>NOT</em> necessary for tree nodes to inherit from this type to implement the AbstractTrees.jl interface. Conversely, all <code>AbstractNode</code> types are required to satisfy the AbstractTrees.jl interface (i.e. they must at least define <a href="#AbstractTrees.children"><code>children</code></a>).</p><p>Package developers should keep in mind when writing methods that most trees <em>will not</em> be of this type. Therefore, any functions which are intended to work on any tree should not dispatch on <code>AbstractNode</code>.</p><p>The type parameter <code>T</code> is the type of the <a href="#AbstractTrees.nodevalue-Tuple{Any}"><code>nodevalue</code></a> of the concrete type descented from <code>AbstractNode</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/AbstractTrees.jl/blob/c63e1dbf65090dfb5060ee6c7139845256310ef7/src/base.jl#L196-L209">source</a></section></article><h2 id="Type-Stability-and-Performance"><a class="docs-heading-anchor" href="#Type-Stability-and-Performance">Type Stability and Performance</a><a id="Type-Stability-and-Performance-1"></a><a class="docs-heading-anchor-permalink" href="#Type-Stability-and-Performance" title="Permalink"></a></h2><p>Because of the recursive nature of trees it can be quite challenging to achieve type stability when traversing it in any way such as iterating over nodes.  Only trees which guarantee that all nodes are of the same type (with <a href="#AbstractTrees.HasNodeType"><code>HasNodeType</code></a>) can be type stable.</p><p>To make it easier to convert trees with non-uniform node types this package provides the <code>StableNode</code> type.</p><article class="docstring"><header><a class="docstring-binding" id="AbstractTrees.StableNode" href="#AbstractTrees.StableNode"><code>AbstractTrees.StableNode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">StableNode{T} &lt;: AbstractNode{T}</code></pre><p>A node belonging to a tree in which all nodes are of type <code>StableNode{T}</code>.  This type is provided so that trees with <a href="#AbstractTrees.NodeTypeUnknown"><code>NodeTypeUnknown</code></a> can implement methods to be converted to type-stable trees with indexable <code>children</code> which allow for efficient traversal and iteration.</p><p><strong>Constructors</strong></p><pre><code class="language-julia">StableNode{T}(x::T, ch)
StableNode(x, ch=())
StableNode{T}(𝒻, node)</code></pre><p><strong>Arguments</strong></p><ul><li><code>x</code>: the value of the constructed node, returned by <a href="#AbstractTrees.nodevalue-Tuple{Any}"><code>nodevalue</code></a>.</li><li><code>ch</code>: the children of the node, each must be of type <code>StableNode</code>.</li><li><code>𝒻</code>: A function which, when called on the node of a tree returns a value which should be wrapped   by a <code>StableNode</code>.  The return value of <code>𝒻</code> must be convertable to <code>T</code> (see example).</li><li><code>T</code>: The value type of the <code>StableNode</code>s in a tree.</li><li><code>node</code>: A node from a tree which is to be used to construct the <code>StableNode</code> tree.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">t = [1, [2,3]]

node = StableNode{Union{Int,Nothing}}(t) do n
    n isa Integer ? convert(Int, n) : nothing
end</code></pre><p>In the above example <code>node</code> is a tree with <a href="#AbstractTrees.HasNodeType"><code>HasNodeType</code></a>, nodes of type <code>StableNode{Union{Int,Nothing}}</code>. The nodes in the new tree corresponding to arrays have value <code>nothing</code> while other nodes have their corresponding <code>Int</code> value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/AbstractTrees.jl/blob/c63e1dbf65090dfb5060ee6c7139845256310ef7/src/base.jl#L221-L254">source</a></section></article><p>To achieve the same performance with custom node types be sure to define at least</p><pre><code class="language-julia">AbstractTrees.NodeType(::Type{&lt;:ExampleNode}) = HasNodeType()
AbstractTrees.nodetype(::Type{&lt;:ExampleNode}) = ExampleNode</code></pre><p>In some circumstances it is also more efficient for nodes to have <a href="#AbstractTrees.ChildIndexing"><code>ChildIndexing</code></a> since this also guarantees the type of the iteration state of the iterator returned by <code>children</code>.</p><h2 id="Additional-Functions"><a class="docs-heading-anchor" href="#Additional-Functions">Additional Functions</a><a id="Additional-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Additional-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="AbstractTrees.getdescendant" href="#AbstractTrees.getdescendant"><code>AbstractTrees.getdescendant</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getdescendant(node, idx)</code></pre><p>Obtain a node from a tree by indexing each level of the tree with the elements of <code>idx</code>.</p><p>This function is defined for all trees regardless of whether they have the <a href="#AbstractTrees.IndexedChildren"><code>IndexedChildren</code></a>. This is because a tree without <a href="#AbstractTrees.IndexedChildren"><code>IndexedChildren</code></a> might have special cases in which all children are indexable, a prominent example being <code>Array</code> which may not have indexable sub-trees (e.g. an array containing a Dict) but there are common special cases in which array trees are fully indexable (e.g. a tree in which every non-leaf node is an array).</p><p>The elements of <code>idx</code> can be any argument to <code>getindex</code>, not necessarily integers.  For example, <code>getdescendant(Dict(&quot;a&quot;=&gt;1), (&quot;a&quot;,))</code> returns <code>1</code>.</p><p>Note that this is a separate concept from indexed trees which by default do not have <code>IndexedChildren()</code>, see <a href="#AbstractTrees.IndexNode"><code>IndexNode</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia">v = [1, [2, [3, 4]]]

getdescendant(v, (2, 2, 1)) == 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/AbstractTrees.jl/blob/c63e1dbf65090dfb5060ee6c7139845256310ef7/src/indexing.jl#L2-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractTrees.nodevalues" href="#AbstractTrees.nodevalues"><code>AbstractTrees.nodevalues</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nodevalues(itr::TreeIterator)</code></pre><p>An iterator which returns the <code>nodevalue</code> of each node in the tree, equivalent to <code>Iterators.map(nodevalue, itr)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/AbstractTrees.jl/blob/c63e1dbf65090dfb5060ee6c7139845256310ef7/src/iteration.jl#L78-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractTrees.ischild" href="#AbstractTrees.ischild"><code>AbstractTrees.ischild</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ischild(node1, node2; equiv=(===))</code></pre><p>Check if <code>node1</code> is a child of <code>node2</code>.</p><p>By default this iterates through <code>children(node2)</code>, so performance may be improved by adding a specialized method for given node type.</p><p>Equivalence is established with the <code>equiv</code> function.  New methods of this function should include this argument or else it will fall back to <code>===</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/AbstractTrees.jl/blob/c63e1dbf65090dfb5060ee6c7139845256310ef7/src/base.jl#L69-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractTrees.isroot" href="#AbstractTrees.isroot"><code>AbstractTrees.isroot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isroot(x)</code></pre><p>Whether <code>x</code> is the absolute root of a tree.  More specifically, this returns <code>true</code> if <code>parent(x) ≡ nothing</code>, or <code>parent(root, x) ≡ nothing</code>.  That is, while any node is the root of some tree, this function only returns true for nodes which have parents which cannot be obtained with the <code>AbstractTrees</code> interface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/AbstractTrees.jl/blob/c63e1dbf65090dfb5060ee6c7139845256310ef7/src/base.jl#L95-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractTrees.intree" href="#AbstractTrees.intree"><code>AbstractTrees.intree</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">intree(node, root; equiv=(≡))</code></pre><p>Check if <code>node</code> is a member of the tree rooted at <code>root</code>.</p><p>By default this traverses through the entire tree in search of <code>node</code>, and so may be slow if a more specialized method has not been implemented for the given tree type.</p><p>Equivalence is established with the <code>equiv</code> function.  Note that new methods should also define <code>equiv</code> or calls may fall back to the default method.</p><p>See also: <a href="#AbstractTrees.isdescendant"><code>isdescendant</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/AbstractTrees.jl/blob/c63e1dbf65090dfb5060ee6c7139845256310ef7/src/base.jl#L105-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractTrees.isdescendant" href="#AbstractTrees.isdescendant"><code>AbstractTrees.isdescendant</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isdescendant(node1, node2; equiv=(≡))</code></pre><p>Check if <code>node1</code> is a descendant of <code>node2</code>. This isequivalent to checking whether <code>node1</code> is a member of the subtree rooted at <code>node2</code> (see <a href="#AbstractTrees.intree"><code>intree</code></a>) except that a node cannot be a descendant of itself.</p><p>Internally this calls <code>intree(node1, node2)</code> and so may be slow if a specialized method of that function is not available.</p><p>Equivalence is established with the <code>equiv</code> function.  Note that new methods should also define <code>equiv</code> or calls may fall back to the default method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/AbstractTrees.jl/blob/c63e1dbf65090dfb5060ee6c7139845256310ef7/src/base.jl#L120-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractTrees.treebreadth" href="#AbstractTrees.treebreadth"><code>AbstractTrees.treebreadth</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">treebreadth(node)</code></pre><p>Get the number of leaves in the tree rooted at <code>node</code>. Leaf nodes have a breadth of one.</p><p>By default this recurses through all nodes in the tree and so may be slow if a more specialized method has not been implemented for the given type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/AbstractTrees.jl/blob/c63e1dbf65090dfb5060ee6c7139845256310ef7/src/base.jl#L147-L154">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractTrees.treeheight" href="#AbstractTrees.treeheight"><code>AbstractTrees.treeheight</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">treeheight(node)</code></pre><p>Get the maximum depth from <code>node</code> to any of its descendants. Leaf nodes have a height of zero.</p><p>By default this recurses through all nodes in the tree and so may be slow if a more specialized method has not been implemented for the given type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/AbstractTrees.jl/blob/c63e1dbf65090dfb5060ee6c7139845256310ef7/src/base.jl#L158-L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractTrees.descendleft" href="#AbstractTrees.descendleft"><code>AbstractTrees.descendleft</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">descendleft(node)</code></pre><p>Descend from the node <code>node</code> to the first encountered leaf node by recursively calling <a href="#AbstractTrees.children"><code>children</code></a> and taking the first child.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/AbstractTrees.jl/blob/c63e1dbf65090dfb5060ee6c7139845256310ef7/src/base.jl#L168-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractTrees.getroot" href="#AbstractTrees.getroot"><code>AbstractTrees.getroot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getroot(node)</code></pre><p>Get the root of the tree containing node <code>node</code>.  This requires <code>node</code> to have the trait <a href="#AbstractTrees.StoredParents"><code>StoredParents</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/AbstractTrees.jl/blob/c63e1dbf65090dfb5060ee6c7139845256310ef7/src/base.jl#L180-L184">source</a></section></article><h2 id="Example-Implementations"><a class="docs-heading-anchor" href="#Example-Implementations">Example Implementations</a><a id="Example-Implementations-1"></a><a class="docs-heading-anchor-permalink" href="#Example-Implementations" title="Permalink"></a></h2><ul><li>All objects in base which define the abstract trees interface are defined in   <a href="https://github.com/JuliaCollections/AbstractTrees.jl/blob/master/src/builtins.jl"><code>builtins.jl</code></a>.</li><li><a href="https://github.com/JuliaCollections/AbstractTrees.jl/blob/master/test/examples/idtree.jl"><code>IDTree</code></a></li><li><a href="https://github.com/JuliaCollections/AbstractTrees.jl/blob/master/test/examples/onenode.jl"><code>OneNode</code></a></li><li><a href="https://github.com/JuliaCollections/AbstractTrees.jl/blob/master/test/examples/onetree.jl"><code>OneTree</code></a></li><li><a href="https://github.com/JuliaCollections/AbstractTrees.jl/blob/master/test/examples/fstree.jl"><code>FSNode</code></a></li><li><a href="https://github.com/JuliaCollections/AbstractTrees.jl/blob/master/test/examples/binarytree.jl"><code>BinaryNode</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="iteration/">Iteration »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 19 January 2023 03:38">Thursday 19 January 2023</span>. Using Julia version 1.8.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
