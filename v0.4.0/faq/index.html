<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>FAQ · AbstractTrees.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">AbstractTrees.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../iteration/">Iteration</a></li><li><a class="tocitem" href="../internals/">Internals</a></li><li class="is-active"><a class="tocitem" href>FAQ</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Why-were-breaking-changes-necessary-for-0.4?"><span>Why were breaking changes necessary for 0.4?</span></a></li><li class="toplevel"><a class="tocitem" href="#Why-aren&#39;t-all-iterators-trees-by-default?"><span>Why aren&#39;t all iterators trees by default?</span></a></li><li class="toplevel"><a class="tocitem" href="#Why-does-treemap-return-a-special-node-type?"><span>Why does <code>treemap</code> return a special node type?</span></a></li><li class="toplevel"><a class="tocitem" href="#Why-is-my-code-type-unstable?"><span>Why is my code type unstable?</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>FAQ</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>FAQ</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaCollections/AbstractTrees.jl/blob/master/docs/src/faq.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="What-are-the-breaking-changes-in-0.4?"><a class="docs-heading-anchor" href="#What-are-the-breaking-changes-in-0.4?">What are the breaking changes in 0.4?</a><a id="What-are-the-breaking-changes-in-0.4?-1"></a><a class="docs-heading-anchor-permalink" href="#What-are-the-breaking-changes-in-0.4?" title="Permalink"></a></h1><p>Most trees which only define methods for the single-argument version of <code>children</code> should not be affected by breaking changes in 0.4, though authors of packages containing these should review the new trait system to ensure they have added any appropriate traits which can improve performance.</p><p>Iterators types do <em>not</em> have breaking changes.</p><p>There are quite a few breaking changes for features of AbstractTrees.jl which were not documented or poorly documented and were therefore unlikely to be used.</p><p>The most significant changes are for indexed trees which now rely on the <a href="../#AbstractTrees.IndexNode"><code>IndexNode</code></a> object and a dedicated set of methods.  Authors of packages using indexed trees should review <a href="../#The-Indexed-Tree-Interface">The Indexed Tree Interface</a>.  Roughly speaking, the changes are</p><ul><li><code>children(tree, node)</code> <span>$\rightarrow$</span> <code>childindices(tree, node_index)</code></li><li><code>Iterator(tree)</code> <span>$\rightarrow$</span> <code>Iterator(IndexNode(tree))</code></li><li>Check if your tree satisfies the <a href="../#AbstractTrees.StoredParents"><code>StoredParents</code></a> or <a href="../#AbstractTrees.StoredSiblings"><code>StoredSiblings</code></a> traits.</li><li>Consider defining <a href="../#AbstractTrees.childrentype"><code>childrentype</code></a> or <a href="../#AbstractTrees.childtype"><code>childtype</code></a> (can make some algorithms closer   to type-stable).</li></ul><h1 id="Why-were-breaking-changes-necessary-for-0.4?"><a class="docs-heading-anchor" href="#Why-were-breaking-changes-necessary-for-0.4?">Why were breaking changes necessary for 0.4?</a><a id="Why-were-breaking-changes-necessary-for-0.4?-1"></a><a class="docs-heading-anchor-permalink" href="#Why-were-breaking-changes-necessary-for-0.4?" title="Permalink"></a></h1><p>Prior to v0.4 AbstractTrees.jl confused the distinct concepts:</p><ul><li>A tree node.</li><li>Values associated with the node (what is now obtained by <a href="../#AbstractTrees.nodevalue-Tuple{Any}"><code>nodevalue</code></a>).</li><li>The position of a node in a tree.</li><li>A tree in its entirety.</li></ul><p>This led to inconsistent implementations particularly of indexed tree types even within AbstractTrees.jl itself.  As of 0.4 the package is much more firmly grounded in the concept of a <em>node</em>, alternative methods for defining trees are simply adaptors from objects to nodes, in particular <a href="../#AbstractTrees.IndexNode"><code>IndexNode</code></a>.</p><p>A summary of major internal changes from 0.3 to 0.4 is as follows:</p><ul><li>All indexed tree methods of basic tree functions have been removed.  Indexed trees now have   dedicated methods such as <code>childindices</code> and <code>parentindex</code>.</li><li>Nodes can now implement <code>nodevalue</code> which allows for distinction between values associated with   the nodes and the nodes themselves.</li><li>All tree navigation is now based on &quot;cursors&quot;.  A cursor provides the necessary information for   moving betweeen adjacent nodes of a tree.  Iterators now specify the movement among cursor   nodes.</li><li>Iterators now depend only on iterator states.  This is mostly for internal convenience and does not   change the external API.</li><li><code>treemap</code> and <code>treemap!</code> have been replaced with versions that depend on <a href="@ref"><code>MapNode</code></a>.</li></ul><h1 id="Why-aren&#39;t-all-iterators-trees-by-default?"><a class="docs-heading-anchor" href="#Why-aren&#39;t-all-iterators-trees-by-default?">Why aren&#39;t all iterators trees by default?</a><a id="Why-aren&#39;t-all-iterators-trees-by-default?-1"></a><a class="docs-heading-anchor-permalink" href="#Why-aren&#39;t-all-iterators-trees-by-default?" title="Permalink"></a></h1><p>Iteration is very widely implemented for Julia types and there are many types which define iteration but which don&#39;t make sense as trees.  Major examples in <code>Base</code> alone include <code>Number</code> and <code>String</code>, <code>Char</code> and <code>Task</code>.  If there are this many examples in <code>Base</code> there are likely to be a lot more in other packages.</p><h1 id="Why-does-treemap-return-a-special-node-type?"><a class="docs-heading-anchor" href="#Why-does-treemap-return-a-special-node-type?">Why does <code>treemap</code> return a special node type?</a><a id="Why-does-treemap-return-a-special-node-type?-1"></a><a class="docs-heading-anchor-permalink" href="#Why-does-treemap-return-a-special-node-type?" title="Permalink"></a></h1><p>As described above, older versions of this package conflate tree nodes with values attached to them. This makes sense for certain built-in types, particularly arrays, but it imposes constraints on what types of nodes a tree can have.  In particular, it requires all nodes to be container types (so that they can contain their children).  It was previously not possible to have a tree in which, e.g. the integer <code>1</code> was anything other than a leaf node.</p><p>The function <code>treemap</code> is special in that it must choose an appropriate output type for an entire tree.  Nodes of this output tree cannot be chosen to be a simple array, since the contents of arrays would be fully-determined by their children.  In other words, a <code>treemap</code> based on arrays can only map leaves.</p><p>Introducing a new type becomes necessary to ensure that it can accommodate arbitrary output types.</p><h1 id="Why-is-my-code-type-unstable?"><a class="docs-heading-anchor" href="#Why-is-my-code-type-unstable?">Why is my code type unstable?</a><a id="Why-is-my-code-type-unstable?-1"></a><a class="docs-heading-anchor-permalink" href="#Why-is-my-code-type-unstable?" title="Permalink"></a></h1><p>Guaranteeing type stability when iterating over trees is challenging to say the least.  There are several major obstacles</p><ul><li>The children of a tree node do not, in general, have the same type as their parent.</li><li>Even if it is easy to infer the type of a node&#39;s immediate children, it is usually much harder to   infer the types of the node&#39;s more distant descendants.</li><li>Navigating a tree requires inferring not just the types of the children but the types of the   children&#39;s <em>iteration states</em>.  To make matters worse, Julia&#39;s <code>Base</code> does not include traits   for describing these, and the <code>Base</code> iteration protocol makes very few assumptions about them.</li></ul><p>All of this means that you are unlikely to get type-stable code from AbstractTrees.jl without some effort.</p><p>The simplest way around this is to define the <code>NodeType</code> trait and <code>nodetype</code> (analogous to <code>Base.IteratorEltype</code> and <code>eltype</code>):</p><pre><code class="language-julia">AbstractTrees.NodeType(::Type{&lt;:ExampleNode}) = HasNodeType()
AbstractTrees.nodetype(::Type{&lt;:ExampleNode}) = ExampleNode</code></pre><p>which is equivalent to asserting that all nodes of a tree are of the same type.  Performance critical code must ensure that it is possible to construct such a tree, which may not be trivial.</p><p>Note that even after defining <code>Base.eltype</code> it might still be difficult to achieve type-stability due to the aforementioned difficulties with iteration states.  The most reliable around this is to ensure that the object returned by <code>children</code> is indexable and that the node has the <code>IndexedChildren</code> state.  This guarantees that <code>Int</code> can always be used as an iteration state.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../internals/">« Internals</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 9 June 2022 15:41">Thursday 9 June 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
